import { useState, useRef, useEffect, useCallback } from 'react';
import { supabase } from '@/integrations/supabase/client';
import { useAuth } from '@/contexts/AuthContext';

export interface AgentSignal {
  id: string;
  symbol: string;
  timeframe: string;
  timestamp: string;
  type: 'BUY' | 'SELL' | 'HOLD';
  confidence: number;
  analysis: string;
  pattern: string;
  price: string;
  risk?: string;
  technicalData: {
    rsi: number;
    macd: number;
    ema9: number;
    ema20: number;
  };
  marketContext: {
    volume: number;
    volatility: number;
    trend: string;
  };
  panorama?: {
    trendDirection: string;
    accuracy: number;
    signalStrength: string;
    marketCondition: string;
    nextLevels?: string;
  };
}

interface UseAgentAnalysisProps {
  symbol: string;
  timeframe: string;
  liveData: any;
  technicalIndicators: any;
  patterns: any;
  enabled: boolean;
}

export const useAgentAnalysis = ({
  symbol,
  timeframe,
  liveData,
  technicalIndicators,
  patterns,
  enabled
}: UseAgentAnalysisProps) => {
  const { user } = useAuth();
  const [signals, setSignals] = useState<AgentSignal[]>([]);
  const [isAnalyzing, setIsAnalyzing] = useState(false);
  const [lastAnalysis, setLastAnalysis] = useState<Date | null>(null);
  
  const intervalRef = useRef<NodeJS.Timeout | null>(null);
  const isRunningRef = useRef(false);

  // Fun√ß√£o para gerar an√°lise independente do Agente
  const generateIndependentAnalysis = useCallback(async () => {
    if (!enabled || !liveData || !technicalIndicators || !user || !isRunningRef.current) {
      return;
    }

    try {
      setIsAnalyzing(true);
      console.log('ü§ñ Agente TradeVision IA: Iniciando an√°lise independente...');

      // Preparar dados para an√°lise
      const marketData = {
        symbol: symbol.replace('/', ''),
        timeframe,
        price: liveData?.price || '0',
        volume: liveData?.volume || '0',
        change24h: liveData?.change || '0%'
      };

      console.log('üîç useAgentAnalysis: Dados recebidos', {
        liveData,
        technicalIndicators,
        patterns
      });

      const technicalData = {
        rsi: technicalIndicators?.rsi14 || technicalIndicators?.RSI || 50,
        macd: technicalIndicators?.macdHistogram || technicalIndicators?.MACD?.histogram || 0,
        ema9: technicalIndicators?.ema9 || technicalIndicators?.EMA?.ema9 || 0,
        ema20: technicalIndicators?.ema20 || technicalIndicators?.EMA?.ema20 || 0,
        sma20: technicalIndicators?.sma20 || technicalIndicators?.SMA?.sma20 || 0,
        bollinger: technicalIndicators?.bollinger || technicalIndicators?.Bollinger || { upper: 0, middle: 0, lower: 0 }
      };

      const patternData = {
        orderBlockDetected: patterns?.orderBlockDetected || false,
        fvgDetected: patterns?.fvgDetected || false,
        bosDetected: patterns?.bosDetected || false,
        chochDetected: patterns?.chochDetected || false,
        orderBlockType: patterns?.orderBlockType || null,
        fvgType: patterns?.fvgType || null
      };

      // An√°lise completa do mercado - panorama detalhado
      const currentPrice = Number(marketData.price);
      const priceChange = Number(marketData.change24h.replace('%', ''));
      const volume = Number(marketData.volume);
      
      // Calcular tend√™ncia baseada nas m√©dias m√≥veis
      const trendDirection = technicalData.ema9 > technicalData.ema20 ? 'ALTA' : 
                            technicalData.ema9 < technicalData.ema20 ? 'BAIXA' : 'CONSOLIDA√á√ÉO';
      
      // An√°lise de for√ßa do RSI
      const rsiStrength = technicalData.rsi > 70 ? 'SOBRECOMPRA' :
                         technicalData.rsi < 30 ? 'SOBREVENDA' :
                         technicalData.rsi > 50 ? 'FORTE' : 'FRACO';
      
      // An√°lise do MACD
      const macdMomentum = technicalData.macd > 0 ? 'MOMENTUM POSITIVO' : 'MOMENTUM NEGATIVO';
      
      // An√°lise de volatilidade
      const volatility = Math.abs(priceChange);
      const volatilityLevel = volatility > 5 ? 'ALTA' : volatility > 2 ? 'M√âDIA' : 'BAIXA';
      
      // An√°lise de volume
      const volumeLevel = volume > 1000000 ? 'ALTO' : volume > 500000 ? 'M√âDIO' : 'BAIXO';

      const analysisMessage = `ü§ñ AN√ÅLISE COMPLETA E DETALHADA DO MERCADO - ${symbol} (${timeframe}):

üìä DADOS ATUAIS DO MERCADO:
‚Ä¢ Pre√ßo Atual: $${currentPrice.toLocaleString()}
‚Ä¢ Varia√ß√£o 24h: ${priceChange > 0 ? '+' : ''}${priceChange.toFixed(2)}%
‚Ä¢ Volume: ${volume.toLocaleString()}
‚Ä¢ Timestamp: ${new Date().toLocaleString()}

üìà AN√ÅLISE T√âCNICA DETALHADA:
‚Ä¢ RSI (14): ${technicalData.rsi.toFixed(1)} - ${rsiStrength} (${technicalData.rsi > 70 ? 'Sobrecarga de compra' : technicalData.rsi < 30 ? 'Sobrecarga de venda' : 'Neutro'})
‚Ä¢ MACD Histogram: ${technicalData.macd.toFixed(4)} - ${macdMomentum} (${technicalData.macd > 0 ? 'Momentum de alta' : 'Momentum de baixa'})
‚Ä¢ EMA 9: $${technicalData.ema9.toFixed(2)} (${technicalData.ema9 > currentPrice ? 'Resist√™ncia' : 'Suporte'})
‚Ä¢ EMA 20: $${technicalData.ema20.toFixed(2)} (${technicalData.ema20 > currentPrice ? 'Resist√™ncia' : 'Suporte'})
‚Ä¢ Tend√™ncia Principal: ${trendDirection}
‚Ä¢ For√ßa da Tend√™ncia: ${Math.abs(technicalData.ema9 - technicalData.ema20) > currentPrice * 0.01 ? 'FORTE' : 'FRACA'}

üéØ PADR√ïES DE MERCADO DETECTADOS:
‚Ä¢ Order Block: ${patternData.orderBlockDetected ? 'SIM - Zona de liquidez institucional' : 'N√ÉO - Sem zona de liquidez'}
‚Ä¢ Fair Value Gap: ${patternData.fvgDetected ? 'SIM - Gap de valor justo' : 'N√ÉO - Sem gap de valor'}
‚Ä¢ Break of Structure: ${patternData.bosDetected ? 'SIM - Quebra de estrutura' : 'N√ÉO - Estrutura mantida'}
‚Ä¢ Change of Character: ${patternData.chochDetected ? 'SIM - Mudan√ßa de car√°ter' : 'N√ÉO - Car√°ter mantido'}

üìä CONTEXTO MACRO DO MERCADO:
‚Ä¢ Volatilidade: ${volatilityLevel} (${volatility.toFixed(2)}%) - ${volatility > 5 ? 'Alta volatilidade, cuidado com stop loss' : volatility > 2 ? 'Volatilidade moderada' : 'Baixa volatilidade, movimento lateral'}
‚Ä¢ Volume: ${volumeLevel} - ${volume > 1000000 ? 'Volume alto, confirma√ß√£o de movimento' : volume > 500000 ? 'Volume m√©dio' : 'Volume baixo, movimento fraco'}
‚Ä¢ Sentimento: ${trendDirection === 'ALTA' ? 'Bullish - Tend√™ncia de alta' : trendDirection === 'BAIXA' ? 'Bearish - Tend√™ncia de baixa' : 'Neutro - Consolida√ß√£o'}

üéØ SOLICITA√á√ÉO DETALHADA: 
Forne√ßa uma an√°lise completa e detalhada incluindo:

1. **TEND√äNCIA PRINCIPAL**: ALTA/BAIXA/CONSOLIDA√á√ÉO com justificativa
2. **ACUR√ÅCIA DA AN√ÅLISE**: 0-100% baseada na converg√™ncia dos indicadores
3. **SINAL ESPEC√çFICO**: BUY/SELL/HOLD com n√≠vel de entrada
4. **JUSTIFICATIVA T√âCNICA DETALHADA**: Explica√ß√£o completa dos indicadores
5. **N√çVEL DE RISCO**: BAIXO/M√âDIO/ALTO com justificativa
6. **PR√ìXIMOS N√çVEIS IMPORTANTES**: Suporte, resist√™ncia e targets
7. **AN√ÅLISE DE MOMENTUM**: For√ßa do movimento atual
8. **RECOMENDA√á√ÉO DE STOP LOSS**: N√≠vel de prote√ß√£o
9. **TIMEFRAME DE VALIDADE**: Quanto tempo o sinal √© v√°lido
10. **CONFIAN√áA NO SINAL**: Porcentagem de confian√ßa baseada na an√°lise

Seja detalhado e espec√≠fico na sua an√°lise, explicando cada ponto t√©cnico e fundamentando suas conclus√µes com os dados fornecidos.`;

      // Chamar edge function para an√°lise independente
      const { data, error } = await supabase.functions.invoke('trade-chat', {
        body: {
          message: analysisMessage,
          userId: user.id,
          sessionId: `agent-complete-analysis-${Date.now()}`,
          realTimeContext: {
            analysisType: 'complete-market-analysis',
            marketData,
            technicalData,
            patternData,
            marketContext: {
              trendDirection,
              rsiStrength,
              macdMomentum,
              volatilityLevel,
              volumeLevel,
              currentPrice,
              priceChange,
              volume
            },
            timestamp: new Date().toISOString(),
            independentMode: true
          }
        }
      });

      if (error) {
        console.error('‚ùå Erro na an√°lise independente do Agente:', error);
        return;
      }

      // Processar resposta do Agente
      const response = data.response || '';
      const confidence = data.confidence || 50;
      
      // Extrair informa√ß√µes estruturadas da resposta
      const extractSignalInfo = (text: string) => {
        const lines = text.split('\n');
        let signalType: 'BUY' | 'SELL' | 'HOLD' = 'HOLD';
        let accuracy = confidence;
        let trend = 'NEUTRAL';
        let risk = 'M√âDIO';
        let nextLevels = '';
        
        for (const line of lines) {
          const upperLine = line.toUpperCase();
          
          // Detectar sinal
          if (upperLine.includes('BUY') || upperLine.includes('COMPRAR') || upperLine.includes('ALTA')) {
            signalType = 'BUY';
          } else if (upperLine.includes('SELL') || upperLine.includes('VENDER') || upperLine.includes('BAIXA')) {
            signalType = 'SELL';
          }
          
          // Detectar tend√™ncia
          if (upperLine.includes('TEND√äNCIA:') || upperLine.includes('TENDENCIA:')) {
            if (upperLine.includes('ALTA')) trend = 'ALTA';
            else if (upperLine.includes('BAIXA')) trend = 'BAIXA';
            else if (upperLine.includes('CONSOLIDA√á√ÉO') || upperLine.includes('CONSOLIDACAO')) trend = 'CONSOLIDA√á√ÉO';
          }
          
          // Detectar acur√°cia
          if (upperLine.includes('ACUR√ÅCIA:') || upperLine.includes('ACURACIA:')) {
            const match = line.match(/(\d+)%/);
            if (match) accuracy = parseInt(match[1]);
          }
          
          // Detectar risco
          if (upperLine.includes('RISCO:')) {
            if (upperLine.includes('BAIXO')) risk = 'BAIXO';
            else if (upperLine.includes('ALTO')) risk = 'ALTO';
            else if (upperLine.includes('M√âDIO') || upperLine.includes('MEDIO')) risk = 'M√âDIO';
          }
          
          // Detectar pr√≥ximos n√≠veis
          if (upperLine.includes('N√çVEIS:') || upperLine.includes('NIVEIS:')) {
            nextLevels = line.replace(/.*[Nn][√çi]veis?:?\s*/i, '');
          }
        }
        
        return { signalType, accuracy, trend, risk, nextLevels };
      };
      
      const signalInfo = extractSignalInfo(response);

      // S√≥ gerar sinal se confian√ßa for suficiente (reduzido para gerar mais sinais)
      if (signalInfo.accuracy >= 30) {
        const signal: AgentSignal = {
          id: `agent-signal-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
          symbol,
          timeframe,
          timestamp: new Date().toISOString(),
          type: signalInfo.signalType,
          confidence: signalInfo.accuracy,
          analysis: response,
          pattern: patternData.orderBlockDetected ? 'Order Block' :
                  patternData.fvgDetected ? 'Fair Value Gap' :
                  patternData.bosDetected ? 'Break of Structure' :
                  patternData.chochDetected ? 'Change of Character' :
                  'An√°lise T√©cnica Completa',
          price: `$${Number(marketData.price).toLocaleString()}`,
          risk: signalInfo.risk,
          technicalData: {
            rsi: technicalData.rsi,
            macd: technicalData.macd,
            ema9: technicalData.ema9,
            ema20: technicalData.ema20
          },
          marketContext: {
            volume: Number(marketData.volume) || 0,
            volatility: Math.abs(Number(marketData.change24h.replace('%', ''))) || 0,
            trend: signalInfo.trend
          },
          panorama: {
            trendDirection: signalInfo.trend,
            accuracy: signalInfo.accuracy,
            signalStrength: signalInfo.accuracy >= 80 ? 'FORTE' : signalInfo.accuracy >= 60 ? 'M√âDIO' : 'FRACO',
            marketCondition: `${volatilityLevel} volatilidade, ${volumeLevel} volume`,
            nextLevels: signalInfo.nextLevels
          }
        };

        // Adicionar sinal √† lista
        setSignals(prev => [signal, ...prev.slice(0, 49)]); // Manter √∫ltimos 50 sinais
        
        // Salvar no banco de dados
        try {
          const { error: dbError } = await supabase
            .from('agent_signals')
            .insert({
              id: signal.id,
              symbol: signal.symbol,
              timeframe: signal.timeframe,
              signal_type: signal.type,
              confidence: signal.confidence,
              analysis: signal.analysis,
              pattern: signal.pattern,
              price: signal.price,
              risk: signal.risk,
              technical_data: signal.technicalData,
              market_context: signal.marketContext,
              user_id: user.id,
              created_at: signal.timestamp
            });

          if (dbError) {
            console.error('‚ùå Erro ao salvar sinal do Agente:', dbError);
          } else {
            console.log('‚úÖ Sinal do Agente salvo no banco de dados');
          }
        } catch (dbErr) {
          console.error('‚ùå Erro ao salvar sinal:', dbErr);
        }

        console.log('üéØ Sinal independente do Agente gerado:', signal);
      } else {
        console.log('‚è∏Ô∏è An√°lise do Agente: Confian√ßa insuficiente ou sinal HOLD');
      }

      setLastAnalysis(new Date());

    } catch (error) {
      console.error('‚ùå Erro na an√°lise independente:', error);
    } finally {
      setIsAnalyzing(false);
    }
  }, [enabled, liveData, technicalIndicators, patterns, symbol, timeframe, user]);

  // Iniciar an√°lise
  const startAnalysis = useCallback(() => {
    if (isRunningRef.current) return;
    
    console.log('ü§ñ Iniciando an√°lise independente do Agente TradeVision IA...');
    isRunningRef.current = true;
    
    // Primeira an√°lise imediatamente
    setTimeout(() => {
      generateIndependentAnalysis();
    }, 2000);
    
    // Continuar an√°lise a cada 1 minuto
    intervalRef.current = setInterval(() => {
      generateIndependentAnalysis();
    }, 60000); // 1 minuto
  }, [generateIndependentAnalysis]);

  // Parar an√°lise
  const stopAnalysis = useCallback(() => {
    console.log('‚è∏Ô∏è Parando an√°lise independente do Agente...');
    isRunningRef.current = false;
    
    if (intervalRef.current) {
      clearInterval(intervalRef.current);
      intervalRef.current = null;
    }
  }, []);

  // Limpar sinais
  const clearSignals = useCallback(() => {
    setSignals([]);
    console.log('üóëÔ∏è Sinais do Agente limpos');
  }, []);

  // Cleanup
  useEffect(() => {
    return () => {
      if (intervalRef.current) {
        clearInterval(intervalRef.current);
      }
    };
  }, []);

  // Auto-start quando habilitado
  useEffect(() => {
    if (enabled && liveData && !isRunningRef.current) {
      startAnalysis();
    } else if (!enabled && isRunningRef.current) {
      stopAnalysis();
    }
  }, [enabled, liveData, startAnalysis, stopAnalysis]);

  return {
    signals,
    isAnalyzing,
    lastAnalysis,
    startAnalysis,
    stopAnalysis,
    clearSignals
  };
};
